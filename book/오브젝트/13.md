# 13 서브클래싱과 서브타이핑

> 상속의 용도는 2가지가 있다. 첫째, 타입계층을 구현. 둘째, 코드의 재사용. 코드의 재사용은 부모, 자식클래스가느이 강한 결합을 야기시키므로 피해야 한다. 이번장에서는 타입계층을 구현하는 법을 설명할 것이고, 먼저 타입과 타입계층에 대해 공부한다.



## 01 타입

### 개념 관점의 타입

타입은 우리가 인지하는 사물의 종류를 나타낸다. 또한 3가지 요소로 구성된다. 심볼, 내연, 외연



### 프로그래밍 언어 관점의 타입

프로그래밍 언어에서 타입은 수행될 수 있는 유효한 오퍼레이션 집합과 미리 약속된 문맥을 제공함으로써 코드의 의미를 정확하게 전달하고, 개발자의 실수를 막아준다.



### 객체지향 패러다임 관점의 타입

객체지향에서 타입을 정의하는 것은 오퍼레이션 -> 퍼블릭 인터페이스를 정의하는 것이다. 그래서 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다.



## 02 타입계층

### 타입 사이의 포함관계

슈퍼타입 - 타입의 정의가 일반적이고, 다른 집합을 포함한다.

서브타입 - 타입의 정의가 구체적이고, 다른 집합에 포함된다.



### 객체지향 프로그래밍과 타입계층



## 03 서브클래싱과 서브타이핑

객체지향 프로그래밍에서 타입은 클래스로 구현하고, 타입계층은 상속을 통해서 구현한다. 그렇다면 어떻게 서브타입과 수퍼타입의 관계가 맺어지는 것일까? 지켜야하는 제약사항은 무엇일까? 타입계층 구현 시 제약사항을 클래스와 상속의 관점에서 보자.



### 언제 상속을 사용해야 하는가?

is-a 관계이거나 client에서 부모클래스타입으로 자식클래스를 사용해도 무방할 때



### is-a 관계

어휘적 정의에 의해서 is-a관계는 잡으면 <u>ex) 펭귄</u> 때문에 코드가 꼬인다. 그래서 기대되는 행동에 따라 타입계층을 구성해야 한다.



### 행동 호환성

행동으로 상속관계를 맺지 않은 경우 해결책이 3가지 있는데, 이 모두 문제가 있다.



### 클라이언트의 기대에 따라 계층 분리하기 

펭귄과 같은 경우 Flyer, Walker 인터페이스로 분리 될 수 있고, bird클래스의 메소드가 필요하다면 합성을 통해 재사용 한다.



### 서브클래싱과 서브타이핑

서브클래싱 - 코드의 재사용을 위한 상속

서브타이핑 - 다형성을 위한 상속이다. 자식클래스가 부모 클래스를 대체할 수 있어야 하고, 이 반대도 가능해야 한다.



## 04 리스코프 치환 원칙

리스코프 치환원칙은 서브타입은 그것의 기반타입에 대해 대체 가능해야 하는데, 여기서 squre는 Rectangle을 대체하지 못한다. 리스코프 치환원칙 위반이다.



### 클라이언트와 대체 가능성

상속관계에서는 클라이언트의 입장에서 자식클래스를 부모클래스로 대체 할 수 있을때만 올바르다. -> 대체 가능성 결정은 클라이언트가 한다.



### is-a 관계 다시 살펴보기

'클라이언트 입장'에서 보았을때, 슈퍼타입과 서브타입의 행동이 호환된다면 is-a관계이다.



### 리스코프 치환 원칙은 유연한 설계의 기반이다.

앞에서 했던 영화의 할인정책은 DIP, LSP, OCP가 한데 어우러져 설계를 확장가능하게 만든 대표적 예이다.

![13-1](./오브젝트/drawio/13-1.png)

**DIP** : Movie와 OverlappedDisoucntPolicy모두 DiscountPolicy에 의존한다. 상위수준 모듈인 Movie와 하위수준 모듈인 OverlappedDiscountPolicy는 모두 추상클래스인 DiscountPolicy에 의존하므로, DIP를 만족한다.

**LSP** : DiscountPolicy와 협력하는 Movie의 관점에서 Movie는 DiscountPolicy의 서브타입인 OverlappedDiscountPolicy와 협력해도 아무 문제없다. 그래서 LSP를 만족한다.

**OCP** : 중복할인 정책이라는 새로운 기능을 추가하기 위해 DiscountPolicy의 서브타입인 OverlappedDiscountPolicy를 추가해도 Movie에는 아무 영향을 끼치지 않는다. 즉, 기능 확장을 위해 기존 코드를 수정할 필요가 없다.

여기서, 자식클래스가 클라이언트 관점에서 부모 클래스를 대체할 수 있다면, 기능 확장을 위해 새로운 자식클래스가 추가되더라도 기존 코드는 수정할 필요가 없다. **<u>정리하자면, LSP는 OCP의 전제조건이다.</u>**



## 05 계약에 의한 설계와 서브타이핑

서브타입이 슈퍼타입의 행동을 하려면 클라이언트나 슈퍼타입 사이에 체결된 계약을 준수해야 한다. 이 계약 조건은 사전조건, 사후조건, 클래스 불변식이다. 이는 부록에서 자세히 다룬다.

### 서브타입과 계약

서브타입이 슈퍼타입의 메소드를 override할때, 사전조건 사후조건에서 다음과 같은 조건을 만족해야 한다.

1. 더 강력한 사전조건 정의 x
2. 더 강력한 사후조건 정의 o





